#include "so_long.h"

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>


#include <stdio.h>
#include "../mlx/mlx.h"


//checks if string has no spaces
int is_string_inside(char*str)
{	
	int i;
 	i = 0;
	int start = 0;
	int end = 0;
	printf("str:%s\n", str);

	while (str[i] != '1' && str[i]!='\n' && str[i]!='\0')
		{
			i++;
			printf("i=%d\n", i);
		}

	start = i;
	printf("start===%d\n", start);
	i = strlen(str)-1;
	while(str[i]!= '1')
		{i--;}

	end = i;
	printf("end==%d\n", end);

	
	while(start!=end)
	{
		if (str[start]!= '1' && str[start] != '0' && str[start] != 'C' && str[start] != 'E' && str[start] != 'P' && str[start] != '\n' && str[start] != '\0')
			{
			return(1);}
		start++;
	}		
	// printf("start%d\n", start);
	return(0);
}



//checks if string is not empty
int is_string_valid(char * str)
{
	//printf("i'm in funct\n");
	//printf("str:%s\n", str);
int i;
 	i = 0;
	int correct_symb = 0;
	while(str[i]!='\n' && str[i]!='\0') 
	{
		if ((str[i] == '1' || str[i] == '0' || str[i] == 'C' || str[i] == 'E' || str[i] == 'P') )
			correct_symb = 1;
		i++;
		//printf("i=%d\n", i);
	}
	if (correct_symb == 0)
		{
		//printf("stringis invalid\n");
		return(0);		
		}

	else
		{
		//printf("stringis is valid\n");
		return(1);
		}
}


int	string_len(char * str)
{	int i;
 	i = 0;
	int j = 0;
	while(str[i]!='\n' && str[i]!='\0') 
	{
		if ((str[i] >= 9 && str[i] <= 13) || str[i] == ' ')
		{	
			i++;			
		}
		else
		{
			j++;
			i++;
		}
	}

	return(j+1);
}

//==============================================MAP===CHECK====================================================
//=============================================================================================================

// The map must contain 1 exit, at least 1 collectible, and 1 starting position to
// be valid.
// If the map contains a duplicates characters (exit/start), you should
// display an error message.
// • The map must be rectangular.
// • The map must be closed/surrounded by walls. If it’s not, the program must return
// an error.
// • You have to check if there’s a valid path in the map.
// • You must be able to parse any kind of map, as long as it respects the above rules.
// • If any misconfiguration of any kind is encountered in the file, the program must
// exit in a clean way, and return "Error\n" followed by an explicit error message of
// your choice.


int check_map (t_game *game)
{	
	// (void)game;
	if(check_map_rectangular(game) == 1)
	{
	printf("Invalid map. Map is not rectangular. Please, check the map.\n");
	exit(0);
	}
	else if(check_map_surrounded(game) == 1)
	{
	printf("Invalid map. Map isn't surrounded by walls. Please, check map.");
	exit(0);
	}
	// else if(check_map_duplicated_chars(game) == 1)
	// {
	// printf("Invalid map. Map has duplicate palyer/exit positions. Please, check map.");
	// exit(0);
	// }
	return(0);
}

int	check_map_rectangular(t_game *game)
{	
	int	x;
	int y;

	x = 0;
	y = 0;
	// printf("rows:%d\n", game->rows);
	// printf("cols:%d\n", game->columns);
	while(y < game->rows)
	{
		while(game->my_map[y][x] != '\0' && game->my_map[y][x] != '\n')	
			{
				x++;				
				// printf("x:%d\n", x);			
			}
		// printf("y:%d\n", y);
		// printf("x:%d\n", x);
		if (x != (game->columns))
			return(1);			
		y++;
		x = 0;
	}
	return(0);
}

int check_map_surrounded(t_game *game)
{
	int	x;
	int y;
	// int first_column;
	// int last_column;

	x = 0;
	y = 0;
		printf("mapstr:!%s!\n", game->my_map[0]);
		printf("mapstr:!%s!\n", game->my_map[1]);
		printf("mapstr:!%s!\n", game->my_map[2]);
		printf("mapstr:!%s!\n", game->my_map[3]);

		while(game->my_map[0][x] != '\n' && game->my_map[0][x] != '\0')
		{
			if (game->my_map[0][x] != '1')
				{		printf("signalnok:%d!\n", x);
					return(1);
				}
			x++;
		}

		
		// printf("colonny:%d\n", game->columns-1);
		// printf("symbol:%c\n", game->my_map[y][game->columns-1]);
		while(y < game->rows-1)
		{
			// printf("y:%d\n", y);
			if (game->my_map[y][0] != '1' || game->my_map[y][game->columns-1] != '1' )
				{	printf("signalnok2:%d!\n", game->columns);
					return(1);
				}
			y++;
		}
		x = 0;
		// printf("y:%d\n", y);
		while(game->my_map[y][x] != '\n' && game->my_map[y][x] != '\0')
		{
			if (game->my_map[y][x] != '1')
				{	printf("signalnok3:%d!\n", x);
					return(1);}
			x++;
		}
	return(0);
}




//=====================================================MAP=====================================================
//=============================================================================================================
char** create_map(int rows, t_game *game, char *av)
{
int fd;
int i = 0;
int j = 0;
int k = 0;
char **map;
char* next_line;
map = malloc(rows*sizeof(char*));
fd = open(av, O_RDONLY);

while(1)
{		
    next_line = get_next_line(fd);
	if(is_string_valid(next_line)>0 || is_string_inside(next_line) == 0)
	{
		map[i] = malloc((string_len(next_line))*sizeof(char));	

		while(next_line[j] != '\n' && next_line[j] != '\0')
		{	
			if(next_line[j] != ' ' && next_line[j] != '\t')
			{
				map[i][k] = next_line[j];
				k++;			
			}
			if (map[i][k]=='C')
				game->target_collectibles++;
			j++;
			
			
		}
		map[i][k]='\0';

	i++;
	j = 0;
	k = 0;
	}
	else
	{
		printf("Error: Map has wrong symbols\n");
		exit(0);
	}
	if(i == rows)
		break;
}
close (fd);

return (map);
}


//-------------------------------------------




int ft_open_map (t_game *game, char* av)
{
int rows = 0;
int columns = 0;
char *next_line;
int fd;

if (!av)
	av = "maps/simple.ber";
fd = open(av, O_RDONLY);	
   
if(fd == -1)
{
	printf("Error! Map hasn't been found!\n");
	exit(0);
}

while(1)
{		
    next_line = get_next_line(fd);
	//printf("line passed to fun:%s\n", next_line);
	if(!next_line )
		break;
	if	(is_string_valid(next_line)>0)
		{	
			columns = string_len(next_line);
			rows++;
			//printf("rows::%d\n", rows);
		}
	if(!next_line)
		break;
}

columns--;
close (fd);
//printf("rows: %d\n", rows);
game->rows = rows;
game->columns = columns;

game->my_map = create_map(rows, game, av);

return(0);
}

//=============================================LOOP================================================================

int		main_loop(t_game *game)
{
	int row= 0;
	int col = 0;
	int coord_y = 0;
	int coord_x = 0;

		
	while (row != game->rows)
	{
		while (col != game->columns)
		{
			if (game->my_map[row][col] == '0')
				mlx_put_image_to_window(game->mlx, game->win, game->img_grass, coord_x, coord_y);
			else if (game->my_map[row][col] == '1')
				mlx_put_image_to_window(game->mlx, game->win, game->img_wall, coord_x, coord_y);
			else if (game->my_map[row][col] == 'P')
				{
					mlx_put_image_to_window(game->mlx, game->win, game->img_player, coord_x, coord_y);
					game->player_pos_x = col;
					game->player_pos_y = row;
				}
			else if (game->my_map[row][col] == 'C')
				{
					mlx_put_image_to_window(game->mlx, game->win, game->img_collect, coord_x, coord_y);
				}
			else if (game->my_map[row][col] == 'E')
				{
					mlx_put_image_to_window(game->mlx, game->win, game->img_exit, coord_x, coord_y);
				}


			col++;
			coord_x = coord_x+32;

		}
		col = 0;
		coord_x = 0;
		row++;
		coord_y = coord_y+32;		
	}	

	return (0);
}

//=============================================================================================================
//==============================================MAIN===========================================================
//=============================================================================================================
int main(int ac, char**	av)
{

		t_game game;
		if (ac !=1 && ac != 2)
		{
			printf("Error! Map path is invalid");
			exit(0);
		}
		

		int		img_width;
		int 	img_height;

		game.pres_but_a_count = 0;
		game.pres_but_d_count = 0;
		game.pres_but_w_count = 0;
		game.pres_but_s_count = 0;
		game.collectibles = 0;
		game.target_collectibles = 0;

		game.moves = 0;
		game.player_pos_x = 160;
		game.player_pos_y = 50;		
		ft_open_map(&game, av[1]);
		check_map (&game);
		printf("target items: %d\n", game.target_collectibles);

		game.mlx = mlx_init();
		game.win = mlx_new_window(game.mlx, (game.columns*32), (game.rows*32), "my_mlx");
		game.img_grass = mlx_xpm_file_to_image(game.mlx, "images/grass.xpm", &img_width, &img_height);
		game.img_wall = mlx_xpm_file_to_image(game.mlx, "images/wall.xpm", &img_width, &img_height);
		game.img_player = mlx_xpm_file_to_image(game.mlx, "images/cat.xpm", &img_width, &img_height);
		game.img_collect = mlx_xpm_file_to_image(game.mlx, "images/collect.xpm", &img_width, &img_height);
		game.img_exit = mlx_xpm_file_to_image(game.mlx, "images/wall_n.xpm", &img_width, &img_height);
	
		mlx_hook(game.win, X_EVENT_KEY_PRESS, 0, &deal_key, &game);
		mlx_hook(game.win, X_EVENT_KEY_RELEASE, 0, &release_key, &game);
		//mlx_key_hook (game.mlx, &deal_key, &game);
		mlx_hook(game.win, X_EVENT_KEY_EXIT, 0, &close_game, &game);
		mlx_loop_hook(game.mlx, &main_loop, &game);

		mlx_loop(game.mlx);
		
		return (0);
}
